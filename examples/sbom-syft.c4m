# sbom-syft.c4m -- Gather SBOM info via Achore's *syft* when chalking.
# :Author: John Viega (john@crashoverride.com)
# :Copyright: 2022, 2023, Crash Override, Inc.
#
# You can add this code either to the configuration embedded into the
# executable, or by putting an external config file somewhere
# (generally the binary should be configured to accept
# ~/.config/chalk/chalk.conf).
#
# For the first approach, use the *chalk confdump* command to output
# the current embedded config to a file, add this code to that file,
# and then reload it with the *chalk confload* command.

# In this example, we're going to use syft to automatically generate
# SBOMs for us, whenever possible. We won't generally need to worry
# about it being pre-installed; we download and run the official
# installer out of /tmp. Note that this approach has some extra risk,
# particularly if the syft installer / binary are silently compromised.
#
# We encourage you to do better-- this is just a basic example.

# Here's the official SYFT installer. Note that we assume the https://
SYFT_INSTALLER := "raw.githubusercontent.com/anchore/syft/main/install.sh"
SYFT_DOWNLOAD  := "curl -sSfL https://" + SYFT_INSTALLER + " | sh -s -- -b /tmp"

# In this example, if you set GIT_FALLBACK to true, then if syft can't
# run or doesn't return any value, then you can use git to report the
# contents of what's under version control, using the git command, if
# found.  You could, of course, nuke all the fallback code.
GIT_FALLBACK   := false
SYFT_PREFIX    := "" # If empty, we know we can't run.
SYFT_SUFFIX    := " -o cyclonedx-json 2>/dev/null"  # CycloneDX by default.

# Here we look for syft, and if we don't find it, we download it.
# Note that we check /tmp when looking for the binary, since it might
# be there from a previous download.
SYFT_LOC, code := system("export PATH=$PATH:/tmp; which syft")
if code != 0 {
  ignored, code := system(SYFT_DOWNLOAD)
  if code != 0 {
    warn("Unable to download syft.")
  }
  else {
    SYFT_LOC := "/tmp/syft"
  }
}
else {
  # Trace messages only show up in verbose mode.
  trace("syft is already present.")
  SYFT_LOC := strip(SYFT_LOC)
}

if SYFT_LOC != "" {
  SYFT_PREFIX := "export PATH=$PATH:/tmp/; " + SYFT_LOC + " "
  info("For SBOM creation: using 'syft' from: " + SYFT_LOC)
}

if GIT_FALLBACK {
  ignored, code := system("which git")
  if code != 0 {
    warn("Cannot find 'git' in path")
    GIT_FALLBACK := false
  }
}

# In con4m global variables are disposable, and not visible from
# callbacks UNLESS you explicitly export them.
export SYFT_PREFIX, SYFT_SUFFIX, GIT_FALLBACK

# When Con4m tries to collect SBOMs for an artifact, it will call this
# function, which dispatches below.
callback get_sboms(filename) {
  if SYFT_PREFIX != "" {
    return syft_sbom(filename)
  }
  elif len(result) == 0 and GIT_FALLBACK {
    return sbom_fallback(filename)
  }
  else {
    return {}
  }
}

# This runs syft from the location calculated above, and checks to see
# if it provided any meaningful data.
#
# Note that we use con4m's special 'result' variable to set a default
# value. This gets used when there's no explicit return w/ a value, and
# makes it easier to change the conditional logic, if needed.
func syft_sbom(filename) {
  result := {}
  out, code := system(SYFT_PREFIX + filename + SYFT_SUFFIX)
  if code == 0 {
    s := "\"components\": []"

    if contains(out, s) {
      info("syft didn't find any components; ignoring.")
    } else {
       return { "syft" : out }
    }
  } else {
    error("Found syft, but couldn't run it.")
  }
}

func sbom_fallback(filename) {
  out, code := system("git -P ls-tree -r HEAD")
  if code == 0 {
    return {"vcsfiles": out }
  }
  return {}
}
