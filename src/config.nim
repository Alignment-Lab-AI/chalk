## Conceptually, this is where ALL information about the configuration
## state lives.  A lot of our calls for accessing configuration state
## are auto-generated by this file though, and in c4autoconf.nim).
##
## This module does also handle loading configurations, including
## built-in ones and external ones.
##
## It also captures some environmental bits used by other modules.
## For instance, we collect some information about the build
## environment here.
##
## :Author: John Viega (john@crashoverride.com)
## :Copyright: 2022, 2023, Crash Override, Inc.

import c4autoconf
export c4autoconf # This is conceptually part of our API.

import options, tables, strutils, algorithm, os, streams
import con4m, nimutils, nimutils/logging, types
import macros except error
export logging, types, nimutils, con4m

proc commentC4mCode(s: string): string =
  let lines = s.split("\n")
  result    = ""
  for line in lines: result &= "# " & line & "\n"

  # Some string constants used in multiple places.
const
  magicUTF8*         = "dadfedabbadabbed"
  tmpFilePrefix*     = "chalk"
  tmpFileSuffix*     = "-file.tmp"
  chalkSpecName*     = "configs/chalk.c42spec"
  getoptConfName*    = "configs/getopts.c4m"
  baseConfName*      = "configs/baseconfig.c4m"
  signConfName*      = "configs/signconfig.c4m"
  sbomConfName*      = "configs/sbomconfig.c4m"
  sastConfName*      = "configs/sastconfig.c4m"
  ioConfName*        = "configs/ioconfig.c4m"
  defCfgFname*       = "configs/defaultconfig.c4m"  # Default embedded config.
  chalkC42Spec*      = staticRead(chalkSpecName)
  getoptConfig*      = staticRead(getoptConfName)
  baseConfig*        = staticRead(baseConfName)
  signConfig*        = staticRead(signConfName)
  sbomConfig*        = staticRead(sbomConfName)
  sastConfig*        = staticRead(sastConfName)
  ioConfig*          = staticRead(ioConfNAme)
  defaultConfig*     = staticRead(defCfgFname) & commentC4mCode(ioConfig)
  versionStr         = staticexec("cat ../chalk.nimble | grep ^version")
  commitID           = staticexec("git rev-parse HEAD")
  archStr            = staticexec("uname -m")
  osStr              = staticexec("uname -o")

var
  configRuntime:      ConfigState
  chalkConfig*:       ChalkConfig
  commandName:        string
  currentOutputCfg:   OutputConfig
  `isChalkingOp?`:    bool

proc runCallback*(cb: CallbackObj, args: seq[Box]): Option[Box] =
  return configRuntime.sCall(cb, args)
proc runCallback*(s: string, args: seq[Box]): Option[Box] =
  return configRuntime.scall(s, args)

macro declareChalkExeVersion(): untyped = parseStmt("const " & versionStr)
declareChalkExeVersion()

proc getChalkExeVersion*(): string   = version
proc getChalkCommitId*(): string     = commitID
proc getChalkPlatform*(): string     = osStr & " " & archStr
proc getCommandName*(): string       = commandName
proc getChalkRuntime*(): ConfigState = configRuntime

proc isChalkingOp*(): bool =
  once:
    `isChalkingOp?` = commandName in chalkConfig.getValidChalkCommandNames()
  return `isChalkingOp?`

proc getOutputConfig*(): OutputConfig =
  once: currentOutputCfg = chalkConfig.outputConfigs[getCommandName()]
  return currentOutputCfg

proc filterByProfile*(dict: ChalkDict, p: Profile): ChalkDict =
  result = ChalkDict()
  for k, v in dict:
    if k in p.keys and p.keys[k].report: result[k] = v

proc filterByProfile*(host, obj: ChalkDict, p: Profile): ChalkDict =
  result = ChalkDict()
  # Let obj-level clobber host-level.
  for k, v in host:
    if k in p.keys and p.keys[k].report: result[k] = v
  for k, v in obj:
    if k in p.keys and p.keys[k].report: result[k] = v

proc lookupCollectedKey*(obj: ChalkObj, k: string): Option[Box] =
  if k in hostInfo:          return some(hostInfo[k])
  if k in obj.collectedData: return some(obj.collectedData[k])
  return none(Box)

template hookCheck(fieldname: untyped) =
  let s = astToStr(fieldName)
  let d = sinkConfData.`needs fieldName`

  if d.isSome() and d.get():
    if not sinkopts.contains(s):
      warn("Sink config '" & sinkconf & "' is missing field '" & s &
           "', which is required by sink '" & sinkname &
           "' (config not installed)")

proc checkHooks*(sinkname:     string,
                 sinkconf:     string,
                 sinkConfData: SinkSpec,
                 sinkopts:     StringTable) =
    hookCheck(secret)
    hookCheck(uid)
    hookCheck(filename)
    hookCheck(uri)
    hookCheck(region)
    hookCheck(headers)
    hookCheck(cacheid)
    hookCheck(aux)

proc orderKeys*(dict: ChalkDict, profile: Profile = nil): seq[string] =
  var tmp: seq[(int, string)] = @[]
  for k, _ in dict:
    var order = chalkConfig.keySpecs[k].normalizedOrder
    if profile != nil and k in profile.keys:
      let orderOpt = profile.keys[k].order
      if orderOpt.isSome():
        order = orderOpt.get()
    tmp.add((order, k))

  tmp.sort()
  result = @[]
  for (_, key) in tmp: result.add(key)

proc getKeySpec*(name: string): Option[KeySpec] =
  if name in chalkConfig.keyspecs: return some(chalkConfig.keyspecs[name])

proc getPluginConfig*(name: string): Option[PluginSpec] =
  if name in chalkConfig.plugins:
    return some(chalkConfig.plugins[name])

proc getSinkConfig*(hook: string): Option[SinkSpec] =
  if chalkConfig.sinks.contains(hook):
    return some(chalkConfig.sinks[hook])
  return none(SinkSpec)

import builtins, collect # Cyclical, but get chalkCon4mBuiltins here.

# Since these are system keys, we are the only one able to write them,
# and it's easier to do it directly here than in the system plugin.
proc stashFlags(winner: ArgResult) =
  var flagStrs: seq[string] = @[]

  for key, value in winner.stringizeFlags():
    if value == "": flagStrs.add("--" & key)
    else:           flagStrs.add("--" & key & "=" & value)

  hostInfo["_OP_CMD_FLAGS"] = pack(flagStrs)

# TODO: static code to validate loaded specs.

proc getEmbeddedConfig(): string =
  result         = defaultConfig
  let extraction = getSelfExtraction()
  if extraction.isSome():
    let selfChalk = extraction.get().extract
    if selfChalk != nil and selfChalk.contains("$CHALK_CONFIG"):
      trace("Found embedded config file in self-chalk.")
      return unpack[string](selfChalk["$CHALK_CONFIG"])

proc findOptionalConf(state: ConfigState): Option[(string, FileStream)] =
  result = none((string, FileStream))
  let
    path     = unpack[seq[string]](state.attrLookup("config_path").get())
    filename = unpack[string](state.attrLookup("config_filename").get())
  for dir in path:
    let fname = dir.joinPath(filename)
    if fname.fileExists():
      info(fname & ": Found config file")
      try:
        return some((fname, newFileStream(fname)))
      except:
        error(fname & ": Could not read configuration file")
        break
    else:
        trace("No configuration file found in " & dir)

var cmdSpec: CommandSpec = nil
proc getArgCmdSpec*(): CommandSpec = cmdSpec
var autoHelp: string = ""
proc getAutoHelp*(): string = autoHelp

proc loadLocalStructs(state: ConfigState) =
  chalkConfig = state.attrs.loadChalkConfig()
  if chalkConfig.color.isSome(): setShowColors(chalkConfig.color.get())
  setLogLevel(chalkConfig.logLevel)
  for i in 0 ..< len(chalkConfig.configPath):
    chalkConfig.configPath[i] = chalkConfig.configPath[i].resolvePath()
  var c4errLevel =  if chalkConfig.con4mPinpoint: c4vShowLoc else: c4vBasic

  if chalkConfig.con4mTraces:
    c4errLevel = if c4errLevel == c4vBasic: c4vTrace else: c4vMax

  setCon4mVerbosity(c4errLevel)

proc stashRuntime(state: ConfigState) =
  configRuntime = state

proc handleCon4mErrors(err, tb: string): bool =
  if chalkConfig == nil or chalkConfig.chalkDebug or true:
    error(err & "\n" & tb)
  else:
    error(err)
  return true

proc handleOtherErrors(err, tb: string): bool =
  error(err)
  return true

# TODO: static tests to validate the c42 configs.
template cmdlineStashTry() =
  if commandName == "ambiguous" and chalkConfig.defaultCommand.isSome():
    setErrorHandler(stack, handleOtherErrors)
    addFinalizeGetOpts(stack, printAutoHelp = false)
    addCallback(stack, loadLocalStructs).run()

  if cmdSpec == nil:
    if stack.getOptOptions.len() > 1:
      if commandName != "ambiguous":
        commandName = "ambiguous"
    else:
      res         = getArgResult(stack)
      commandName = res.command
      cmdSpec     = res.parseCtx.finalCmd
      autoHelp    = res.getHelpStr()
      setArgs(res.args[commandName])

      res.stashFlags()

template doRun() =
  try:
    discard run(stack)
    cmdlineStashTry()
  except:
    error("Could not load configuration files. exiting.")
    quit(1)

proc loadAllConfigs*() =
  var res: ArgResult # Used across macros above.

  let
    toStream = newStringStream
    stack    = newConfigStack()

  stack.addSystemBuiltins().
      addCustomBuiltins(chalkCon4mBuiltins).
      setErrorHandler(handleCon4mErrors).
      addGetoptSpecLoad().
      addSpecLoad(chalkSpecName, toStream(chalkC42Spec)).
      addCallback(stashRuntime).
      addConfLoad(baseConfName, toStream(baseConfig)).
      addCallback(loadLocalStructs).
      addConfLoad(getoptConfName, toStream(getoptConfig)).
      setErrorHandler(handleOtherErrors).
      addStartGetOpts(printAutoHelp = false).addCallback(loadLocalStructs).
      setErrorHandler(handleCon4mErrors).
      addConfLoad(ioConfName,   toStream(ioConfig)).
      addConfLoad(signConfName, toStream(signConfig)).
      addConfLoad(sbomConfName, toStream(sbomConfig)).
      addConfLoad(sastConfName, toStream(sastConfig)).
      addCallback(stashRuntime).
      addCallback(loadLocalStructs)
  doRun()

  # Next, do self extraction, and get the embedded config.
  # The embedded config has already been validated.
  let configFile = getEmbeddedConfig()

  stack.addConfLoad("<<embedded config>>", toStream(configFile)).
        addCallback(loadLocalStructs)
  doRun()

  let optConf = stack.configState.findOptionalConf()
  if optConf.isSome():
    let (fName, stream) = optConf.get()
    var embed = stream.readAll()
    stack.addConfLoad(fName, toStream(embed)).addCallback(loadLocalStructs)
    doRun()
    hostInfo["_OP_CONFIG"] = pack(configFile)
