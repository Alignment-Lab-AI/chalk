## Conceptually, this is where ALL information about the configuration
## state lives.  A lot of our calls for accessing configuration state
## are auto-generated by this file though, and in c4autoconf.nim).
##
## This module does also handle loading configurations, including
## built-in ones and external ones.
##
## It also captures some environmental bits used by other modules.
## For instance, we collect some information about the build
## environment here.
##
## :Author: John Viega (john@crashoverride.com)
## :Copyright: 2022, 2023, Crash Override, Inc.

import c4autoconf
export c4autoconf # This is conceptually part of our API.

import options, tables, strutils, algorithm, os, streams, sugar
import con4m, nimutils, nimutils/logging, types
import macros except error
export logging, types, nimutils, con4m

proc commentC4mCode(s: string): string =
  let lines = s.split("\n")
  result    = ""
  for line in lines: result &= "# " & line & "\n"

  # Some string constants used in multiple places.
const
  magicUTF8*         = "dadfedabbadabbed"
  tmpFilePrefix*     = "chalk"
  tmpFileSuffix*     = "-file.tmp"
  defCfgFname        = "configs/defaultconfig.c4m"  # Default embedded config.
  chalkC42Spec       = staticRead("configs/chalk.c42spec")
  baseConfig         = staticRead("configs/baseconfig.c4m")
  signConfig         = staticRead("configs/signconfig.c4m")
  sbomConfig         = staticRead("configs/sbomconfig.c4m")
  sastConfig         = staticRead("configs/sastconfig.c4m")
  ioConfig*          = staticRead("configs/ioconfig.c4m")
  defaultConfig*     = staticRead(defCfgFname) & commentC4mCode(ioConfig)
  versionStr         = staticexec("cat ../chalk.nimble | grep ^version")
  commitID           = staticexec("git rev-parse HEAD")
  archStr            = staticexec("uname -m")
  osStr              = staticexec("uname -o")

var
  chalkCon4mBuiltins: seq[(string, BuiltinFn)]
  ctxChalkConf*:      ConfigState
  chalkConfig*:       ChalkConfig
  commandName:        string
  currentOutputCfg:   OutputConfig
  `isChalkingOp?`:    bool
let
  (c42Obj*, c42Ctx*) = c42Spec(chalkC42Spec, "<embedded spec>").get()

macro declareChalkExeVersion(): untyped = parseStmt("const " & versionStr)
declareChalkExeVersion()

proc getChalkExeVersion*(): string = version
proc getChalkCommitId*(): string   = commitID
proc getChalkPlatform*(): string   = osStr & " " & archStr
proc getCon4mBuiltins*(): seq[(string, BuiltinFn)] = chalkCon4mBuiltins
proc getCommandName*(): string = commandName
proc setCommandName*(s: string) =
  commandName = s

proc isChalkingOp*(): bool =
  once:
    `isChalkingOp?` = commandName in chalkConfig.getValidChalkCommandNames()
  return `isChalkingOp?`

proc getOutputConfig*(): OutputConfig =
  once: currentOutputCfg = chalkConfig.outputConfigs[getCommandName()]
  return currentOutputCfg

proc filterByProfile*(dict: ChalkDict, p: Profile): ChalkDict =
  result = ChalkDict()
  for k, v in dict:
    if k in p.keys and p.keys[k].report: result[k] = v

proc filterByProfile*(host, obj: ChalkDict, p: Profile): ChalkDict =
  result = ChalkDict()
  # Let obj-level clobber host-level.
  for k, v in host:
    if k in p.keys and p.keys[k].report: result[k] = v
  for k, v in obj:
    if k in p.keys and p.keys[k].report: result[k] = v

proc lookupCollectedKey*(obj: ChalkObj, k: string): Option[Box] =
  if k in hostInfo:          return some(hostInfo[k])
  if k in obj.collectedData: return some(obj.collectedData[k])
  return none(Box)

proc getChalkMark*(obj: ChalkObj): ChalkDict =
  let profile = chalkConfig.profiles[getOutputConfig().chalk]

  if profile.enabled == false:
    error("FATAL: invalid to disable the chalk profile when inserting." &
          " did you mean to use the virtual chalk feature?")
    quit(1)
  return hostInfo.filterByProfile(obj.collectedData, profile)

proc setChalkCon4mBuiltIns*(fns: seq[(string, BuiltinFn)]) {.inline.} =
  # Set from builtins.nim; instead of a cross-dependency, we let it
  # call us to set.
  chalkCon4mBuiltins = fns

template hookCheck(fieldname: untyped) =
  let s = astToStr(fieldName)
  let d = sinkConfData.`needs fieldName`

  if d.isSome() and d.get():
    if not sinkopts.contains(s):
      warn("Sink config '" & sinkconf & "' is missing field '" & s &
           "', which is required by sink '" & sinkname &
           "' (config not installed)")

proc checkHooks*(sinkname:     string,
                 sinkconf:     string,
                 sinkConfData: SinkSpec,
                 sinkopts:     StringTable) =
    hookCheck(secret)
    hookCheck(uid)
    hookCheck(filename)
    hookCheck(uri)
    hookCheck(region)
    hookCheck(headers)
    hookCheck(cacheid)
    hookCheck(aux)

macro addSetter(funcName, varType: untyped, s: static[string]) =
  let varName = newLit(s)
  let varSym  = newIdentNode(s)
  result = quote do:
    proc `funcName`*(val: `varType`) =
      discard ctxChalkConf.setOverride(`varName`, some(pack(val)))
      chalkConfig.`varSym` = val

addSetter(setLoadSbomTools,       bool,        "load_sbom_tools")
addSetter(setLoadSastTools,       bool,        "load_sast_tools")
addSetter(setLoadDefaultSigning,  bool,        "load_default_signing")
addSetter(setConfigPath,          seq[string], "config_path")
addSetter(setConfigFileName,      string,      "config_filename")
addSetter(setAllowExternalConfig, bool,        "allow_external_config")
addSetter(setConsoleLogLevel,     string,      "log_level")
addSetter(setVirtualChalk,        bool,        "virtual_chalk")
addSetter(setPublishDefaults,     bool,        "publish_defaults")
addSetter(setRecursive,           bool,        "recursive")
addSetter(setUseReportCache,      bool,        "use_report_cache")
addSetter(setReportCacheLocation, string,      "report_cache_location")
addSetter(setContainerImageId,    string,      "container_image_id")
addSetter(setContainerImageName,  string,      "container_image_name")

proc setConfigFile*(val: string) =
  let (head, tail) = val.splitPath()

  setConfigPath(@[head])
  setConfigFileName(tail)
  setAllowExternalConfig(true)

proc setColor*(val: bool) =
  discard ctxChalkConf.setOverride("color", some(pack(val)))
  setShowColors(val)
  chalkConfig.color = some(val)

proc setArtifactSearchPath*(val: seq[string]) =
  if len(val) == 0:
    return

  chalkConfig.artifactSearchPath = @[]

  for item in val:
    chalkConfig.artifactSearchPath.add(item.resolvePath())

  discard ctxChalkConf.setOverride("artifact_search_path", some(pack(val)))

template disableObject(c4mName:    string,
                       objtype:    untyped,
                       possiblelist: string) =
  let list = possiblelist.split(",")
  for objname in list:
    if objname notin chalkConfig.objtype:
      warn(objname & ": Could not disable-- not found")
    else:
      let field = c4mName & "." & objname & ".enabled"
      discard ctxChalkConf.setOverride(field, some(pack(false)))
      chalkConfig.objtype[objname].enabled = false

template enableObject(c4mName:      string,
                      objtype:      untyped,
                      possiblelist: string) =
  let list = possiblelist.split(",")
  for objname in list:
    if objname notin chalkConfig.objtype:
      warn(objname & ": Could not enable-- not found")
    else:
      let field = c4mName & "." & objname & ".enabled"
      discard ctxChalkConf.setOverride(field, some(pack(true)))
      chalkConfig.objtype[objname].enabled = true

proc disableProfile*(s: string) = disableObject("profile", profiles, s)
proc disableReport*(s: string)  = disableObject("custom_report", reportSpecs, s)
proc disablePlugin*(s: string)  = disableObject("plugin", plugins, s)
proc disableTool*(s: string)    = disableObject("tool", tools, s)
proc enableProfile*(s: string)  = enableObject("profile", profiles, s)
proc enableReport*(s: string)   = enableObject("custom_report", reportSpecs, s)
proc enablePlugin*(s: string)   = enableObject("plugin", plugins, s)
proc enableTool*(s: string)     = enableObject("tool", tools, s)

proc orderKeys*(dict: ChalkDict): seq[string] =
  var tmp: seq[(int, string)] = @[]
  for k, _ in dict:
    tmp.add((chalkConfig.keySpecs[k].outputOrder, k))

  tmp.sort()
  result = @[]
  for (_, key) in tmp: result.add(key)

proc getKeySpec*(name: string): Option[KeySpec] =
  if name in chalkConfig.keyspecs: return some(chalkConfig.keyspecs[name])

proc getPluginConfig*(name: string): Option[PluginSpec] =
  if name in chalkConfig.plugins:
    return some(chalkConfig.plugins[name])

proc getSinkConfig*(hook: string): Option[SinkSpec] =
  if chalkConfig.sinks.contains(hook):
    return some(chalkConfig.sinks[hook])
  return none(SinkSpec)

# Do last-minute sanity-checking so we can give better error messages
# more easily.  This function currently runs once for each config
# loading, to do any sanity checking.  Could probably do more with it.
# A lot of what's currently here should eventually move to
# auto-generated bits in the con4m spec, though.
proc postProcessConfig() =
  # Actually, not validation, but get this done early.

  if chalkConfig.color.isSome(): setShowColors(chalkConfig.color.get())

  setLogLevel(chalkConfig.logLevel)

  # Take any paths and turn them into absolute paths.
  for i in 0 ..< len(chalkConfig.artifactSearchPath):
    chalkConfig.artifactSearchPath[i] =
      chalkConfig.artifactSearchPath[i].resolvePath()

  for i in 0 ..< len(chalkConfig.configPath):
    chalkConfig.configPath[i] = chalkConfig.configPath[i].resolvePath()

  # Make sure the sinks specified are all sinks we have implementations
  # for; this should always be true in the base config, but is nice
  # to have the check for development.

  when not defined(release):
    for sinkname, _ in chalkConfig.sinks:
      if getSink(sinkname).isNone():
        warn("Config declared sink '" & sinkname & "', but no " &
          "implementation exists")

const baseRep = "<compile_location>/src/configs/"
template internalStack(config, name: string, gettr: (ChalkConfig) -> bool) =
  if chalkConfig.gettr():
    if not ctxChalkConf.stackConfig(config, baseRep & name, c42Ctx): quit(1)
    trace("loaded:  " & name)
  else:
    trace("skipped loading: " & name)

proc loadBaseConfiguration*() =
  ## This function loads the built-in configuration, which is split
  ## into two con4m files, the base definitions file, and the default
  ## I/O configuration.

  # For our internal configurations, if we mess up, we want to see
  # all the debug info.  We'll turn that off later though.
  setCon4mVerbosity(c4vMax)

  let
    (x, ok) = firstRun(contents       = baseConfig,
                       filename       = "<base-configuration>",
                       spec           = c42Obj,
                       addBuiltins    = true,
                       customFuncs    = chalkCon4mBuiltins,
                       evalCtx        = c42Ctx)
  if not ok: quit(1)
  ctxChalkConf = x
  # We need to make chalkConfig is made available for the other configs.
  chalkConfig  = ctxChalkConf.attrs.loadChalkConfig()
  postProcessConfig()

proc loadOptionalConfigurations*() =
  internalStack(signConfig, "signconfig.c4m", getLoadDefaultSigning)
  internalStack(sbomConfig, "sbomconfig.c4m", getLoadSbomTools)
  internalStack(sastConfig, "sastconfig.c4m", getLoadSastTools)
  # This one isn't technically optional, we load it no matter what,
  # and you have to undo its actions explicitly if you want, to make sure
  # it's hard to get in a state where there's no good output configuration.
  # Still, it couldn't go in the base config, b/c it needs chalkConfig to
  # have loaded.
  if not ctxChalkConf.stackConfig(ioConfig, baseRep & "ioconfig.c4m", c42Ctx):
    quit(1)
  # Make all our changes available directly from our generated data structures.
  chalkConfig = ctxChalkConf.attrs.loadChalkConfig()
  postProcessConfig()
  setCon4mVerbosity(c4vShowLoc)

proc loadEmbeddedConfig*(selfOpt: Option[ChalkObj]): bool =
  var confString: string

  if selfOpt.isNone(): confString = defaultConfig
  else:
    let selfChalk = selfOpt.get().extract

    # We extracted a CHALK object from our own executable.  Check for a
    # $CHALK_CONFIG key, and if there is one, run that configuration
    # file, before loading any on-disk configuration file.
    if selfChalk == nil or not selfChalk.contains("$CHALK_CONFIG"):
      trace("No embedded configuration found.")
      confString = defaultConfig
    else:
      confString = unpack[string](selfChalk["$CHALK_CONFIG"])

  try:
    discard ctxChalkConf.stackConfig(confString, "<embedded conf>", c42Ctx)
  except:
    if getCommandName() == "setconf":
      return true
    else:
      error("(when loading embedded config): " & getCurrentExceptionMsg())
      error("Embedded configuration is invalid. Use 'setconf' command to fix")
      return false

  chalkConfig = ctxChalkConf.attrs.loadChalkConfig()
  postProcessConfig()
  trace("Loaded embedded configuration file")

  var c4errLevel =  if chalkConfig.con4mPinpoint: c4vShowLoc else: c4vBasic

  if chalkConfig.con4mTraces:
    c4errLevel = if c4errLevel == c4vBasic: c4vTrace else: c4vMax

  setCon4mVerbosity(c4errLevel)

  return true

proc loadUserConfigFile*(commandName: string): Option[string] =
  var
    path     = chalkConfig.getConfigPath()
    filename = chalkConfig.getConfigFileName() # the base file name.
    fname:     string              # configPath / baseFileName
    loaded:    bool   = false
    contents:  string = ""

  for dir in path:
    fname = dir.joinPath(filename)
    if fname.fileExists(): break
    trace("No configuration file found in " & dir)

  if fname != "" and fname.fileExists():
    info(fname & ": Loading config file")
    try:
      var
        fd  = newFileStream(fname)
        res = ctxChalkConf.stackConfig(fd, fname, c42ctx)

      if not res:
        error(fname & ": invalid configuration not loaded.")
        return none(string)
      else:
        fd.setPosition(0)
        contents    = fd.readAll()
        loaded      = true
        chalkConfig = ctxChalkConf.attrs.loadChalkConfig()
        postProcessConfig()

    except Con4mError: # config file didn't load:
      error(getCurrentExceptionMsg())
      info(fname & ": config file not loaded")
      trace("ignore_broken_conf is false: terminating.")
      quit()

  if loaded:
    info(fname & ": Loaded configuration file")
    return some(contents)

  else:
    info("No user config file loaded.")
    return none(string)
