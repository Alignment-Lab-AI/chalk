%{H Chalk Configuration Files }%

In their simplest form, they are fairly typical key-value configuration files for setting default values.

For instance, you can set some basic properties like so:

%{c
color: true
log_level: "warn" {brown}# Don't print out informational bits.
keyspec {red}CHALK_PTR{cyan} \{
  {brown}# This field is meant to be a URL to redirect people from the artifact
  {brown}# to where the full metadata is kept.
  value: {green}"https://www.myrepo.com/chalklookup/$\{chalkid\}"
\}
}%

If you run {bold}{appName} defaults{reset}, the last table will show configuration variables you can set in your configs.

The {bold}keyspec{reset} object type is used to define all the properties of the metadata fields that we can collect at any phase.  See {bold}{appName} help keyspec{reset} for an introduction to the types of metadata in chalk, and {bold}{appName} help keyspec props{reset} for the fields inside keyspec objects.

Generally, understanding keyspec fields is helpful for understanding metadata keys, but you only need to write these sections if you're defining new metadata (for instance, when writing a plugin).

However, there will be some cases where it's useful to override fields keyspec objects.

If you want to override a field, you just need to redefine it.  For instance, if you want to change the order in which metadata keys output by default, you can change the keyspec's {bold}output_order{reset} field.  Let's day that you wanted the {red}TIMESTAMP{reset} field (which defaults to 3), to go after the {red}CHALK_PTR{reset} field (which defaults to 400).

First, let's look at the base configuration for the timestamp field:
%{c
keyspec {red}TIMESTAMP{cyan} \{
    kind:             {green}Chalk   {brown} # An inherited enum value
    type:             {green}int     {brown} # An actual type literal
    standard:         {green}true    {brown} # A bool literal
    system:           {green}true
    conf_as_system:   {green}true
    since:            {green}"0.1.0" {brown} # A string literal
    output_order:     {green}3
\}
}%

You can simply write:
%{c
  keyspec.{red}TIMESTAMP.{cyan}output_order = {green}401
}%

This will clobber the output_order field for the base configuration.  Note that this syntax is identical to the following:
%{c
keyspec {red}TIMESTAMP{cyan} \{
  output_order: {green}401
\}
}%

The section style and property style are the same, and : and = do the same thing too.  The format should be really familiar to anyone who has ever written a configuration file.

Note that some properties cannot be overridden; you will get an error loading your config file if you try to redefine them.  In fact, many properties in keyspect sections cannot be modified.

Whether fields are locked or not depends on the metadata key.  For instance, the metadata key {bold}MAGIC{reset}, which is only used to identify chalk marks in artifacts, must always appear first in any context in which it appears. So its output_order field is locked.

Lock information will be coming soon to the detail you see when you run, for example, {bold}{appName} help key TIMESTAMP{reset}.

For fields in keyspecs that you can set, some keys (especially those not marked as 'system' keys) can have their value set, either statically once the configuration loads, via the 'value' property, or dynamically, on a per-artifact basis with the 'callback' property.

For instance, even though you cannot override it, the {red}CHALK_RAND{reset} metadata field, which produces a new random 64-bit number for each artifact chalked (in hex format), is implemented in the base configuration as so:

%{c
  keyspec.{red}CHALK_RAND.{cyan}callback: {green}func call_rand

  func {red}call_rand{cyan}({green}key{cyan}) \{
    return {green} $(lower(hex(rand())))  {brown}# $() converts items to strings
  \}
}%

Chalk embeds a small, efficient DSL called {bold}con4m{reset}, specifically made to intertwine configuration and customization with lightweight code.

Chalk aims to make it both easy and flexible to capture arbitrary metadata about software artifacts, the fact that the world isn't homogenous requires a lot of flexibility that can definitely require advanced customization. Con4m was designed explicitly to be a CONfiguration file for (4) Most people, but make it really easy for those who need to do more advanced customization to do so.

Everything is strongly typed statically wherever possible, and almost fully type interenced (one only needs to specify types when a function call is ambiguous... con4m does static dispatch for everything currently).

This gives us the flexibility to change how Chalk behaves based on the operating environment. For instance, if you have two data stores, one for things running AWS, and one for everything else, you could decide to do different things with a key, depending on whether AWS is going to get used.  For instance:

%{c
keyspec {red}CHALK_PTR{cyan} \{
  if envExists({green}"AWS_S3_BUCKET_URI"{cyan}) and envExists({green}"AWS_ACCESS_SECRET"{cyan}) \{
    value: {green}"s3://some-bucket/chalk-$\{artifactid\}"
  \} else \{
    value: {green}"https://www.myrepo.com/chalklookup/$\{artifactid\}"
  \}
\}
}%

This is equally written as:
%{c
  if envExists({green}"AWS_S3_BUCKET_URI"{cyan}) and envExists({green}"AWS_ACCESS_SECRET"{cyan}) \{
    keyspec.{red}CHALK_PTR.{cyan}value = {green}"s3://some-bucket/chalk-$\{artifactid\}"
  \} else \{
    keyspec.{red}CHALK_PTR.{cyan}value = {green}"https://www.myrepo.com/chalklookup/$\{artifactid\}"
  \}
}%

Chalk has typical core data types, including strings, ints, floats, lists and dictionaries. Strings used as values need to be put in quotes. It also has a bunch of other data types that are used internally.  See the con4m manual (link below) for more.

%{h Configuration stacking}%
Chalk configuration files {invert}stack{reset}. Specifically:

- The system loads a base configuration file that loads the underlying schema and some core implementation details.

- A second set of configurations are run, unless completely disabled by command-line flag, setting up third party tools like SAST tools and SBOM tools (You can also disable these via your config file, of course).

- An 'embedded' configuration file loads, that is carried around with the chalk executable (which can be changed). This configuration typically configures when and where to send different kinds of output, and can contain any custom metadata collection. See '{appName} help output' for more information on output.

- A user configuration file loads.

The result of the configuration file executing is a set of key / value pairs. For those pairs, items defined in the most recent configuration file take priority, unless fields get "locked" (primarily, key bits of the underlying metadata schema are locked to help ensure correct metadata collection).

Con4m's features are documented at {red}https://github.com/crashappsec/con4m{reset}. It comes with a number of built-in functions that can be called from the configuration file. chalk exports all of those, and adds other builtins.

See {bold}{appName} help builtins{reset} for a list of builtin functions that can be called from the configuration file that are specific to Chalk (we also make available all of Con4m's builtins).
