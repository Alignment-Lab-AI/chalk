##
## Copyright (c) 2023, Crash Override, Inc.
##
## This file is part of Chalk
## (see https://crashoverride.com/docs/chalk)
##

## Builtin attestation implementation(s).


# installs attestation and returns true if it succeeded.

func install_cosign() {
  # Follow https://docs.sigstore.dev/attestation/installation/
  # to install attestation
  #
  # First attempt to install the go version

  go_path := find_exe("go", [])

  if go_path != "" {
    install_out, ok := system("go install github.com/sigstore/cosign/v2/cmd/cosign@latest")
    if ok != 0 {
      warn("unable to install attestation into $GOPATH/bin/cosign; " +
            "attempting curl install")
    } else {
      return true
    }
  }

  # go was not present (or errored) - attempt to install via curl in /tmp
  host_arch := arch()
  host_os := osname()
  if host_os == "macosx" {
    host_os := "darwin"
  }

  install_name := "cosign-" + host_os + "-" + host_arch
  install_url  := "https://github.com/sigstore/cosign/releases/latest/download/" + install_name
  contents     := url_get(install_url)

  trace("Downloaded cosign.")
  write_file("/tmp/cosign", contents)
  trace(run("chmod +x /tmp/cosign"))

  cosign_path := find_exe("cosign", ["/tmp"])

  if cosign_path != "" {
    trace("Successfully installed attestation into: " + cosign_path)
    return true
  }

  trace("Unable to install cosign (cannot write to tmp?)")
  return false
}

func load_cosign_binary() {
  result             := ""
  supplemental_path  := [env("GOPATH") + "/bin", "~/go/bin", "/tmp"]
  attestation_binary := find_exe("cosign", supplemental_path)

  if attestation_binary == "" {
    if install_cosign() {
      attestation_binary := find_exe("cosign", supplemental_path)
      if attestation_binary == "" {
        error("cosign could not be found!!!")
        return attestation_binary
      }
    }
  }

  return attestation_binary
}

func install_minisign() {

  host_os := osname()
  contents := ""
  inflate_cmd := ""
  if host_os == "macosx" or host_os == "darwin" {
    trace("macosx")
    install_url  := "https://github.com/jedisct1/minisign/releases/download/0.11/minisign-0.11-macos.zip"
    inflate_cmd  := "unzip /tmp/minisign.zip -d /tmp/"
    contents     := url_get(install_url)
    write_file("/tmp/minisign.zip", contents)
  }
  elif host_os == "linux" {
    trace("linux")
    install_url  := "https://github.com/jedisct1/minisign/releases/download/0.11/minisign-0.11-linux.tar.gz"
    inflate_cmd  := "tar -zxf /tmp/minisign.tar.gz -C /tmp/" 
    contents     := url_get(install_url)
    write_file("/tmp/minisign.tar.gz", contents)
  }
  else {
    trace("unsupoprtted OS for minisign "+ host_os)
  }

  trace("Downloaded minisign.")
  trace(run(inflate_cmd))
  trace(run("chmod +x /tmp/minisign"))

  minisign_path := find_exe("minisign", ["/tmp"])

  if minisign_path != "" {
    trace("Successfully installed attestation into: " + minisign_path)
    return true
  }

  trace("Unable to install minisign (cannot write to tmp?)")
  return false

}

func load_minisign_binary() {
  result             := ""

  attestation_binary := find_exe("minisign", ["/tmp"])
  if attestation_binary == "" {
    if install_minisign() {
      attestation_binary := find_exe("minisign", ["/tmp"])
      if attestation_binary == "" {
        error("minisign could not be found!!!")
        return attestation_binary
      }
    }
  }

  return attestation_binary
  }
