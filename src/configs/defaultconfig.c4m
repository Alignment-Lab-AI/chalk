## This is the default user configuration that ships with Chalk.
##
## This config lays out reasonable defaults, but you're free to
## customize it.  You probably are seeing this because you ran 'chalk
## dump'; you can edit this file and load a new one into the Chalk
## binary via 'chalk load' (well, at least you can on Linux machines).
##
## This file will run before any external configuration file.
## Command-line flags get evaluated before this runs, and end up
## getting priority over everything by default.
##
## If you somehow mess up your configuration, you can run:
## 'chalk load default'
##
##
## To test a configuration file, we recommend running it as an
## external configuration before loading it.  HOWEVER:
##
## WARNING! WARNING! WARNING! IMPORTANT!
## Some things in this config file are "write-once" values to prevent
## validation errors for things that could be very subtle issues.
##
## Generally, if you just export this file and use it as both an
## internal configuration and an external configuration, you will get
## errors telling you that you're trying to set a value that has
## already been set, and can't be set again.
##
## Specifically, you will probably get this error:
##
##  You cannot assign to the (locked) attribute sink.
##  sink:    "post"
##
## This happens because your embedded config already set it, and your
## external one tries to do it again.  Specifically, the first defined
## sink output configuration below already was set by the base config.
## The value is locked to prevent you from accidentally changing it to
## "file" yet having the other parameters be for http POST.
## Therefore, when testing a configuration using an external
## configuration file, you need to pass the --no-embedded-config flag
## at the command line.
##
## :Author: John Viega (john@crashoverride.com)
## :Copyright: 2022, 2023, Crash Override, Inc.

# The following default commands are currently valid:
# help, insert, extract, version, docker
#
# The default only gets used if nothing else is given at the command
# line, at all.  If you pass any flags at all, you must pass in a
# command.
#
# If you pick a default command, note that, when this script asks for
# the command via the argv0() call, the result will be "default", NOT
# the value you pick.  So make sure to set up your output
# configuration properly if you change this value.
#

# Uncomment the next line for chalk to assume 'docker' when no command is
# provided.

# default_command: "docker"

# Note that the := assignment operator keeps variables local to your
# configuration. If you use just : or =, the configuration checker
# will reject your configuration.
cmd     := argv0()
args    := argv()

# If not provided, log_level will default to "warn".
# Options for log_level are:
# "trace" (show verbose messages)
# "info"  (show default messages)
# "warn"  (don't show informational messages, but do show warnings and errors)
# "error" (show ONLY actual fatal errors)
# "none"  (show nothing, not even errors)
#
# You can configure where these messages go; they get published to the
# "logs" topic, which automatically is hooked to stderr by default.
#
# Note that, if the user didn't supply a command on the command line,
# then con4m will not yet have figured out what command *will* run;
# this file can change the value of `default_command`.
#
# In such a case, the value of cmd will be "not_supplied".

if env_exists("CHALK_LOG_LEVEL") {
  log_level: env("CHALK_LOG_LEVEL")
} else {
  quieter_cmds := ["docker", "exec"]

  if cmd == "not_supplied" and quieter_cmds.contains(default_command) {
    log_level: "error"
  } elif quieter_cmds.contains(cmd) {
    log_level: "error"
  } else {
    # Uncomment this to print the message when the config runs.
    # Though, then you won't be using the default config, even though
    # it claims to be!
    #
    # info("Using the default config. Use 'chalk load' to load a new one.")

    log_level: "info"
  }
}

# By default, all collected metadata gets added to the chalk inserted
# into the artifact.  If you provide the CHALK_PTR key, then most
# things will NOT go into the chalk, which assumes you put it
# somewhere else, where the CHALK_PTR points. In this example
# configuration, if you provide a value for ptr_url (a local variable
# specific to this config file), it'll use it.
#
# And, if you provide the right AWS S3 environment variables, this
# config will automatically use the S3 bucket's URL as that pointer,
# and only write a minimal chalk into artifacts.
ptr_url := ""

## I/O CONFIGURATION

# This makes sure the built-in functionality for keeping a backup log
# of reporting output is enabled. This is meant to be useful if
# there's a network connectivity issue.  We won't use the sink if a
# file-based sink is configured.

use_report_cache: true


# The sink config gets loaded on first subscription, so if
# virtual isn't on, let's not ever create an empty file.
#
# Note that `virtual_chalk` is a pre-defined configuration attribute.
if virtual_chalk {
 subscribe("virtual", "virtual_chalk_log")
}

# This private variable tracks whether we have a sink configured via
# environment variable.  If you do, we will turn off console reporting
# later in the config.
configured_sink := false

# Here we're going to check envionment variables to see what sinks are
# configured.  They are all subscribed to the "primary" report.  Note
# that, if you configure a log file, and have the "report_cache" on,
# this config turns it off, but can be re-enabled by removing the
# appropriate line(s) below, or by overriding at the command line.

if env_exists("CHALK_USAGE_URL") {
    crashoverride_usage_reporting_url: env("CHALK_USAGE_URL")
}

sink_config my_https_config {
  sink:    "post"
  uri:     env("CHALK_POST_URL")

  if env_exists("TLS_CERT_FILE") {
    pinned_cert_file: env("TLS_CERT_FILE")
  }

  if env_exists("CHALK_POST_HEADERS") {
    headers: mime_to_dict(env("CHALK_POST_HEADERS"))
  }
}

sink_config my_s3_config {
  sink:    "s3"
  enabled: true
  uri:     env("AWS_S3_BUCKET_URI")
  secret:  env("AWS_ACCESS_SECRET")
  uid:     env("AWS_ACCESS_ID")
}

sink_config my_file_config {
  enabled:  true
  sink:     "file"
  filename: env("CHALK_REPORT_LOG")
}

sink_config my_rotating_config {
    enabled:  true
    sink:     "rotating_log"
    max:      <<100mb>>
    filename: env("CHALK_ROTATING_LOG")
}

if env_exists("CHALK_POST_URL") {
  subscribe("report", "my_https_config")
  configured_sink := true
  if ptr_url == "" {
    ptr_url := env("CHALK_POST_URL")
  }
}

if env_exists("AWS_S3_BUCKET_URI") {
  if not env_exists("AWS_ACCESS_ID") {
     warn("To configure AWS must provide AWS_ACCESS_ID")
  } elif not env_exists("AWS_ACCESS_SECRET") {
     warn("To configure AWS must provide AWS_ACCESS_SECRET")
  } else {
    subscribe("report", "my_s3_config")
    configured_sink := true
    if ptr_url == "" {
      ptr_url := env("AWS_S3_BUCKET_URI")
    }
  }
}

if env_exists("CHALK_REPORT_LOG") {
  subscribe("report", "my_file_config")
  configured_sink := true
  use_report_cache: false
}

if env_exists("CHALK_ROTATING_LOG") {
  subscribe("report", "my_rotating_config")
  configured_sink := true
  use_report_cache: false
}

if configured_sink {
  # 'json_console_out' is the default sink configuration for reporting if
  # the user doesn't do anything different. Here, we're undoing it.
  unsubscribe("report", "json_console_out")
}

# This switches which default report we use for actual chalking, to
# insert more minimal data.  We do this when we see ptr_url set, which
# can either be done manually, or is done above if the right environment
# variables are provided.

if ptr_url != "" {
    keyspec.CHALK_PTR.value = strip(ptr_url)
    outconf.insert.chalk = "chalking_ptr"
}

#% INTERNAL
docker.wrap_entrypoint = false
# Set this to the sink you want entry points to use for reporting.
# docker.entrypoint_report_sink = ""
#% END

# Below this point is configuration code that has already run, before
# your base configuration loaded. You can safely delete these comments
# when you reload your base configuration.
